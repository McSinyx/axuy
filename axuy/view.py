# view.py - maintain view on game world
# Copyright (C) 2019  Nguyá»…n Gia Phong
#
# This file is part of Axuy
#
# Axuy is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Axuy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Axuy.  If not, see <https://www.gnu.org/licenses/>.

from itertools import chain, combinations_with_replacement, permutations
from math import cos, sin, pi
from random import random

import glfw
import moderngl
import numpy as np
from pyrr import Matrix44

from .misc import hex2f4, resource_filename

# map.npy is generated by ../tools/mapgen
SPACE = np.load(resource_filename('map.npy'))
OXY = np.float32([[0, 0, 0], [1, 0, 0], [1, 1, 0],
                  [1, 1, 0], [0, 1, 0], [0, 0, 0]])
OYZ = np.float32([[0, 0, 0], [0, 1, 0], [0, 1, 1],
                  [0, 1, 1], [0, 0, 1], [0, 0, 0]])
OZX = np.float32([[0, 0, 0], [1, 0, 0], [1, 0, 1],
                  [1, 0, 1], [0, 0, 1], [0, 0, 0]])
NEIGHBORS = set(chain.from_iterable(map(
    permutations, combinations_with_replacement(range(-1, 2), 3))))

SPEED = 2
MOUSE_SPEED = 1

with open(resource_filename('space.vert')) as f: VERTEX_SHADER = f.read()
with open(resource_filename('space.frag')) as f: FRAGMENT_SHADER = f.read()


class View:
    """World map and camera placement.

    Parameters
    ----------
    mapid : iterable of ints
        order of nodes to sort map.npy.
    context : moderngl.Context
        OpenGL context from which ModernGL objects are created.

    Attributes
    ----------
    space : np.ndarray of bools
        3D array of occupied space.
    oxy, oyz, ozx : set of tuples of ints
        Coordinates of cube faces to be rendered.
    prog : moderngl.Program
        Processed executable code in GLSL.
    vao : moderngl.VertexArray
        Vertex data of the map.
    pos : np.ndarray of np.float32
        Camera position.
    hangle, vangle : floats
        Viewing angle.
    forward, up, right : np.ndarray of np.float32
        Directions.
    fps : float
        Currently rendered frames per second.
    """

    def __init__(self, mapid, context):
        space = np.stack([SPACE[i] for i in mapid]).reshape(4, 4, 3, 3, 3, 3)
        self.space = np.zeros([12, 12, 9])
        self.oxy, self.oyz, self.ozx = set(), set(), set()
        for (x, y, z, i, j, k), occupied in np.ndenumerate(space):
            if occupied: self.set_cube(x*3 + i, y*3 + j, z*3 + k)

        self.prog = context.program(vertex_shader=VERTEX_SHADER,
                                    fragment_shader=FRAGMENT_SHADER)
        self.prog['color'].write(hex2f4('eeeeec').tobytes())

        vertices = []
        for i in self.oxy: vertices.extend(i+j for j in OXY)
        for i in self.oyz: vertices.extend(i+j for j in OYZ)
        for i in self.ozx: vertices.extend(i+j for j in OZX)
        vbo = context.buffer(np.stack(vertices).astype('f4').tobytes())
        self.vao = context.simple_vertex_array(self.prog, vbo, 'in_vert')

        x, y, z = random()*12, random()*12, random()*9
        while self.space[int(x)][int(y)][int(z)]:
            x, y, z = random()*12, random()*12, random()*9
        self.pos = np.float32([x, y, z])
        self.hangle = random() * pi * 2
        self.vangle = 0
        self.set_directions()

        self.fps = 60.0

    def set_cube(self, x, y, z):
        """Mark occupied space and faces for rendering."""
        i, j, k = (x+1) % 12, (y+1) % 12, (z+1) % 9
        for tx, ty, tz in NEIGHBORS:
            xt, yt, zt = x + tx*12, y + ty*12, z + tz*9
            it, jt, kt = i + tx*12, j + ty*12, k + tz*9
            self.oxy.update(((xt, yt, zt), (xt, yt, kt)))
            self.oyz.update(((xt, yt, zt), (it, yt, zt)))
            self.ozx.update(((xt, yt, zt), (xt, jt, zt)))
        self.space[x][y][z] = 1

    def set_directions(self):
        """Set forward, up and right directions based on view angle."""
        self.forward = np.float32([cos(self.vangle) * sin(self.hangle),
                                   sin(self.vangle),
                                   cos(self.vangle) * cos(self.hangle)])
        self.right = np.float32([-cos(self.hangle), 0, sin(self.hangle)])
        self.up = np.cross(self.right, self.forward)

    def move(self, direction):
        """Move camera in the given direction."""
        dr = direction / self.fps * SPEED
        i, j, k = self.pos + dr
        if not self.space[int(i%12)][int(j%12)][int(k%9)]: self.pos += dr
        x, y, z = self.pos
        self.pos = x%12, y%12, z%9

    def look(self, window, xpos, ypos):
        """Look according to cursor position.

        Present as a callback for GLFW CursorPos event.
        """
        center = np.float32(glfw.get_window_size(window)) / 2
        dh, dv = center - [xpos, ypos]
        self.vangle += MOUSE_SPEED / self.fps * dv
        if cos(self.vangle) > 0:
            self.hangle += MOUSE_SPEED / self.fps * dh
        else:
            self.hangle -= MOUSE_SPEED / self.fps * dh
        self.set_directions()

    def render(self, width, height, fov):
        """Render the map."""
        proj = Matrix44.perspective_projection(fov, width/height, 0.0001, 4)
        look = Matrix44.look_at(self.pos, self.pos + self.forward, self.up)
        self.prog['mvp'].write((proj*look).astype(np.float32).tobytes())
        self.prog['eye'].write(np.float32(self.pos).tobytes())
        self.vao.render(moderngl.TRIANGLES)
