# view.py - maintain view on game world
# Copyright (C) 2019  Nguyá»…n Gia Phong
#
# This file is part of Axuy
#
# Axuy is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Axuy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Axuy.  If not, see <https://www.gnu.org/licenses/>.

from itertools import chain, combinations_with_replacement, permutations
from math import cos, sin, pi
from random import random

import glfw
import moderngl
import numpy as np
from pyrr import matrix33, Matrix44

from .misc import hex2f4, resource_filename

# map.npy is generated by ../tools/mapgen
SPACE = np.load(resource_filename('map.npy'))
OXY = np.float32([[0, 0, 0], [1, 0, 0], [1, 1, 0],
                  [1, 1, 0], [0, 1, 0], [0, 0, 0]])
OYZ = np.float32([[0, 0, 0], [0, 1, 0], [0, 1, 1],
                  [0, 1, 1], [0, 0, 1], [0, 0, 0]])
OZX = np.float32([[0, 0, 0], [1, 0, 0], [1, 0, 1],
                  [1, 0, 1], [0, 0, 1], [0, 0, 0]])
NEIGHBORS = set(chain.from_iterable(map(
    permutations, combinations_with_replacement((-1, 0, 1), 3))))

SPEED = 2
MOUSE_SPEED = 1

with open(resource_filename('space.vert')) as f: VERTEX_SHADER = f.read()
with open(resource_filename('space.frag')) as f: FRAGMENT_SHADER = f.read()


class View:
    """World map and camera placement.

    Parameters
    ----------
    mapid : iterable of ints
        order of nodes to sort map.npy.
    context : moderngl.Context
        OpenGL context from which ModernGL objects are created.

    Attributes
    ----------
    space : np.ndarray of bools
        3D array of occupied space.
    oxy, oyz, ozx : set of tuples of ints
        Coordinates of cube faces to be rendered.
    prog : moderngl.Program
        Processed executable code in GLSL.
    vao : moderngl.VertexArray
        Vertex data of the map.
    x, y, z : floats
        Camera position.
    pos : np.ndarray of np.float32
        Camera position in a numpy array.
    rotation : np.ndarray of np.float32
        Rotational matrix.
    forward, up, right : np.ndarray of np.float32
        Directions.
    fps : float
        Currently rendered frames per second.
    """

    def __init__(self, mapid, context):
        space = np.stack([SPACE[i] for i in mapid]).reshape(4, 4, 3, 3, 3, 3)
        self.space = np.zeros([12, 12, 9])
        self.oxy, self.oyz, self.ozx = set(), set(), set()
        for (x, y, z, i, j, k), occupied in np.ndenumerate(space):
            if occupied: self.set_cube(x*3 + i, y*3 + j, z*3 + k)

        self.prog = context.program(vertex_shader=VERTEX_SHADER,
                                    fragment_shader=FRAGMENT_SHADER)
        self.prog['color'].write(hex2f4('eeeeec').tobytes())

        vertices = []
        for i in self.oxy: vertices.extend(i+j for j in OXY)
        for i in self.oyz: vertices.extend(i+j for j in OYZ)
        for i in self.ozx: vertices.extend(i+j for j in OZX)
        vbo = context.buffer(np.stack(vertices).astype('f4').tobytes())
        self.vao = context.simple_vertex_array(self.prog, vbo, 'in_vert')

        self.x, self.y, self.z = random()*12, random()*12, random()*9
        while self.space[int(self.x)][int(self.y)][int(self.z)]:
            self.x, self.y, self.z = random()*12, random()*12, random()*9
        self.rotation = np.float32([[1, 0, 0], [0, 1, 0], [0, 0, -1]])

        self.fps = 60.0

    @property
    def pos(self):
        """Return camera position in a numpy array."""
        return np.float32([self.x, self.y, self.z])

    @pos.setter
    def pos(self, postion):
        """Set camera postion."""
        self.x, self.y, self.z = postion

    @property
    def right(self):
        """Return right direction."""
        return self.rotation[0]

    @property
    def upward(self):
        """Return upward direction."""
        return self.rotation[1]

    @property
    def forward(self):
        """Return forward direction."""
        return self.rotation[2]

    def set_cube(self, x, y, z):
        """Mark occupied space and faces for rendering."""
        i, j, k = (x+1) % 12, (y+1) % 12, (z+1) % 9
        for tx, ty, tz in NEIGHBORS:
            xt, yt, zt = x + tx*12, y + ty*12, z + tz*9
            it, jt, kt = i + tx*12, j + ty*12, k + tz*9
            self.oxy.update(((xt, yt, zt), (xt, yt, kt)))
            self.oyz.update(((xt, yt, zt), (it, yt, zt)))
            self.ozx.update(((xt, yt, zt), (xt, jt, zt)))
        self.space[x][y][z] = 1

    def move(self, direction):
        """Move camera in the given direction."""
        dr = direction / self.fps * SPEED
        i, j, k = self.pos + dr
        if not self.space[int(i%12)][int(j%12)][int(k%9)]: self.pos += dr
        self.pos = self.x % 12, self.y % 12, self.z % 9

    def look(self, window, xpos, ypos):
        """Look according to cursor position.

        Present as a callback for GLFW CursorPos event.
        """
        center = np.float32(glfw.get_window_size(window)) / 2
        yaw, pitch = (center - [xpos, ypos]) / self.fps * MOUSE_SPEED
        self.rotation = (matrix33.create_from_y_rotation(yaw) @
                         matrix33.create_from_x_rotation(pitch) @ self.rotation)

    def render(self, width, height, fov):
        """Render the map."""
        proj = Matrix44.perspective_projection(fov, width/height, 0.0001, 4)
        look = Matrix44.look_at(self.pos, self.pos + self.forward, self.upward)
        self.prog['mvp'].write((proj*look).astype(np.float32).tobytes())
        self.prog['eye'].write(np.float32(self.pos).tobytes())
        self.vao.render(moderngl.TRIANGLES)
