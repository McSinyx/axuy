# view.py - maintain view on game world
# Copyright (C) 2019  Nguyá»…n Gia Phong
#
# This file is part of Axuy
#
# Axuy is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Axuy is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with Axuy.  If not, see <https://www.gnu.org/licenses/>.

__doc__ = 'Axuy module for map class'

from itertools import product, starmap
from operator import add

import moderngl
import numpy as np
from pyrr import Matrix44

from .misc import color, neighbors, resource_filename
from .pico import Picobot

# map.npy is generated by ../tools/mapgen
SPACE = np.load(resource_filename('map.npy'))

OXY = np.float32([[0, 0, 0], [1, 0, 0], [1, 1, 0],
                  [1, 1, 0], [0, 1, 0], [0, 0, 0]])
OYZ = np.float32([[0, 0, 0], [0, 1, 0], [0, 1, 1],
                  [0, 1, 1], [0, 0, 1], [0, 0, 0]])
OZX = np.float32([[0, 0, 0], [1, 0, 0], [1, 0, 1],
                  [1, 0, 1], [0, 0, 1], [0, 0, 0]])
OCTAHEDRON = np.float32([[+1/4, 0, 0], [0, +1/4, 0], [0, 0, +1/4],
                         [+1/4, 0 ,0], [0, +1/4, 0], [0, 0, -1/4],
                         [+1/4, 0 ,0], [0, -1/4, 0], [0, 0, +1/4],
                         [+1/4, 0 ,0], [0, -1/4, 0], [0, 0, -1/4],
                         [-1/4, 0 ,0], [0, +1/4, 0], [0, 0, +1/4],
                         [-1/4, 0 ,0], [0, +1/4, 0], [0, 0, -1/4],
                         [-1/4, 0 ,0], [0, -1/4, 0], [0, 0, +1/4],
                         [-1/4, 0 ,0], [0, -1/4, 0], [0, 0, -1/4]])
TETRAHEDRON = np.float32([[+1, +1, +1], [+1, -1, -1], [-1, +1, -1],
                          [-1, -1, +1], [+1, -1, -1], [-1, +1, -1],
                          [+1, +1, +1], [-1, -1, +1], [-1, +1, -1],
                          [+1, +1, +1], [-1, -1, +1], [+1, -1, -1]])

with open(resource_filename('space.vert')) as f: VERTEX_SHADER = f.read()
with open(resource_filename('space.frag')) as f: FRAGMENT_SHADER = f.read()


class View:
    """World map and camera placement.

    Parameters
    ----------
    mapid : iterable of length 48 of ints
        order of nodes to sort map.npy.
    context : moderngl.Context
        OpenGL context from which ModernGL objects are created.

    Attributes
    ----------
    space : np.ndarray of shape (12, 12, 9) of bools
        3D array of occupied space.
    prog : moderngl.Program
        Processed executable code in GLSL.
    mapva : moderngl.VertexArray
        Vertex data of the map.
    camera : Picobot
        Protagonist whose view is the camera.
    """

    def __init__(self, mapid, context):
        space = np.stack([SPACE[i] for i in mapid]).reshape(4, 4, 3, 3, 3, 3)
        self.space = np.zeros([12, 12, 9], dtype=bool)
        for (i, j, k, x, y, z), occupied in np.ndenumerate(space):
            if occupied: self.space[i*3 + x][j*3 + y][k*3 + z] = 1

        vertices = []
        for (x, y, z), occupied in np.ndenumerate(self.space):
            if self.space[x][y][z-1] ^ occupied:
                vertices.extend(starmap(add, product(neighbors(x, y, z), OXY)))
            if self.space[x-1][y][z] ^ occupied:
                vertices.extend(starmap(add, product(neighbors(x, y, z), OYZ)))
            if self.space[x][y-1][z] ^ occupied:
                vertices.extend(starmap(add, product(neighbors(x, y, z), OZX)))

        self.prog = context.program(vertex_shader=VERTEX_SHADER,
                                    fragment_shader=FRAGMENT_SHADER)
        self.prog['bg'].write(color('Background').tobytes())
        mapvb = context.buffer(np.stack(vertices).astype(np.float32).tobytes())
        self.mapva = context.simple_vertex_array(self.prog, mapvb, 'in_vert')

        self.camera = Picobot(self.space)

    @property
    def pos(self):
        """Camera position in a NumPy array."""
        return np.float32([self.camera.x, self.camera.y, self.camera.z])

    @property
    def right(self):
        """Camera right direction."""
        return self.camera.rotation[0]

    @property
    def upward(self):
        """Camera upward direction."""
        return self.camera.rotation[1]

    @property
    def forward(self):
        """Camera forward direction."""
        return self.camera.rotation[2]

    def render(self, width, height, fov):
        """Render the map."""
        visibility = 360 / fov
        self.prog['visibility'].write(np.float32(visibility).tobytes())
        self.prog['camera'].write(np.float32(self.pos).tobytes())

        projection = Matrix44.perspective_projection(fov, width/height,
                                                     9e-6, visibility)
        view = Matrix44.look_at(self.pos, self.pos + self.forward, self.upward)
        vp = view @ projection

        self.prog['mvp'].write(vp.astype(np.float32).tobytes())
        self.prog['color'].write(color('Aluminium').tobytes())
        self.mapva.render(moderngl.TRIANGLES)
